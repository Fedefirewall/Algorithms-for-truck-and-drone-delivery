
ranking selection

def solutions_crossover(parent_1_index,parent_2_index):
    parent_1=population[parent_1_index].copy()
    parent_2=population[parent_2_index].copy()

    children_1=[]
    for path_parent_1,path_parent_2 in zip(parent_1,parent_2):
        path_children_1=[]
        if(len(path_parent_1)==0):
            path_children_1=path_parent_2
        elif(len(path_parent_2)==0):
            path_children_1=path_parent_1
        else:
            cuts_points=random.choices(range(0,len(path_parent_1)),k=2)
            cuts_points.sort()
            sub_path_parent_1=path_parent_1[cuts_points[0]:cuts_points[1]]
            remaining_path_parent_2=[node for node in path_parent_2 if node not in sub_path_parent_1]
            while len(path_children_1)<cuts_points[0] and len(remaining_path_parent_2)>0:
                path_children_1.append(remaining_path_parent_2.pop(0))
            path_children_1+=sub_path_parent_1
            if len(remaining_path_parent_2)>0:
                path_children_1+=remaining_path_parent_2
            children_1.append(path_children_1)

    children_2=[]
    for path_parent_1,path_parent_2 in zip(parent_1,parent_2):
        path_children_2=[]
        if(len(path_parent_1)==0):
            path_children_2=path_parent_2
        elif(len(path_parent_2)==0):
            path_children_2=path_parent_1
        else:
            cuts_points=random.choices(range(0,len(path_parent_2)),k=2)
            cuts_points.sort()
            sub_path_parent_2=path_parent_2[cuts_points[0]:cuts_points[1]]     
            remaining_path_parent_1=[node for node in path_parent_1 if node not in sub_path_parent_2]
            while len(path_children_2)<cuts_points[0] and len(remaining_path_parent_1)>0:
                path_children_2.append(remaining_path_parent_1.pop(0))
            path_children_2+=sub_path_parent_2
            if len(remaining_path_parent_1)>0:
                path_children_2+=remaining_path_parent_1
            children_2.append(path_children_2)        
            